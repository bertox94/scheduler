CREATE TABLE IF NOT EXISTS public.singleorder
(
    id                   int4           NOT NULL,
    descr                text           NULL,
    wt                   bool           NULL,
    amount               numeric(10, 2) NULL,
    plannedexecutiondate date           NULL,
    CONSTRAINT singleorder_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.repeatedorder
(
    id      int4           NOT NULL,
    descr   text           NULL,
    wt      bool           NULL,
    amount  numeric(10, 2) NULL,
    f1      int4           NULL,
    f2      text           NULL,
    f3      text           NULL,
    rdd     int4           NULL,
    rmm     int4           NULL,
    rlim    bool           NULL,
    rinitdd int4           NULL,
    rinitmm int4           NULL,
    rinityy int4           NULL,
    rfindd  int4           NULL,
    rfinmm  int4           NULL,
    rfinyy  int4           NULL,
    CONSTRAINT repeatedorder_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS transaction
(
    id            integer generated by default as identity
        primary key,
    descr         text,
    amount        numeric,
    orderid       integer,
    executiondate date,
    iduser        integer
);

DROP FUNCTION IF EXISTS public.getFirstId();
CREATE FUNCTION public.getFirstId()
    RETURNS INTEGER AS
$$
DECLARE
    missing_id INTEGER;
BEGIN
    WITH all_ids AS (SELECT id
                     FROM SingleOrder
                     UNION
                     SELECT id
                     FROM RepeatedOrder),
         numbers AS (SELECT generate_series(1, (SELECT COALESCE(MAX(id), 0) + 1 FROM all_ids)) AS generate_series)
    SELECT MIN(n.generate_series)
    INTO missing_id
    FROM numbers n
             LEFT JOIN all_ids a ON n.generate_series = a.id
    WHERE a.id IS NULL;

    RETURN missing_id;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS public.generateOrderOccurrences(INT8, INT8);

CREATE FUNCTION public.generateOrderOccurrences(
    end_preview INT8,
    id_user INT8
)
    RETURNS VOID AS
$$
DECLARE
    rec       RECORD; -- Variable to hold each row from repeatedorder
    init_date DATE; -- Variable for calculating the date in the loop
    curr_date DATE; -- Variable for tracking the current date in the loop
    end_date  DATE; -- Calculated end date
    end_prev  DATE; -- Calculated end date
    iter      INT; --iteration number
BEGIN
    end_prev := to_timestamp(end_preview)::date;
    FOR rec IN SELECT * FROM repeatedorder
        LOOP
            IF rec.f2 = 'days' THEN
                curr_date := curr_date + INTERVAL '1 day' * rec.f1 * iter;
            ELSIF rec.f2 = 'months' THEN
                init_date := MAKE_DATE(rec.rinityy, rec.rinitmm, 1);
                IF rec.rdd > EXTRACT('DAY' FROM (date_trunc('month', init_date) + interval '1 month - 1 day')::date) OR
                   rec.f3 = 'eom' THEN
                    init_date = (date_trunc('month', init_date) + interval '1 month - 1 day')::date;
                ELSE
                    init_date = MAKE_DATE(rec.rinityy, rec.rinitmm, rec.rdd);
                END IF;
            ELSIF rec.f2 = 'years' THEN
                curr_date := curr_date + INTERVAL '1 year' * rec.f1 * iter;
            ELSE
                RAISE EXCEPTION 'Invalid frequency type on order ID %', rec.id;
            END IF;

            IF rec.rlim THEN
                end_date := MAKE_DATE(rec.rinityy, rec.rinitmm, 1);
                IF rec.rdd > EXTRACT('DAY' FROM (date_trunc('month', end_date) + interval '1 month - 1 day')::date) OR
                   rec.f3 = 'eom' THEN
                    end_date = (date_trunc('month', end_date) + interval '1 month - 1 day')::date;
                ELSE
                    end_date = MAKE_DATE(rec.rinityy, rec.rinitmm, rec.rdd);
                END IF;
                end_date = LEAST(end_date, end_prev);
            ELSE
                end_date = end_prev;
            END IF;


            -- Loop until the planned date exceeds the end date
            iter := 1;
            curr_date = init_date;
            WHILE curr_date <= end_date
                LOOP
                    -- Insert the occurrence into the new table
                    INSERT INTO public.transaction (orderid, iduser, descr, executiondate, amount)
                    VALUES (rec.id, id_user, rec.descr, curr_date, rec.amount);

                    -- Increment the planned date based on the frequency type
                    IF rec.f2 = 'days' THEN
                        curr_date := curr_date + INTERVAL '1 day' * rec.f1 * iter;
                    ELSIF rec.f2 = 'months' THEN
                        curr_date = init_date + INTERVAL '1 month' * rec.f1 * iter;
                        IF rec.f3 = 'eom' THEN
                            curr_date = (date_trunc('month', curr_date) + interval '1 month - 1 day')::date;
                        END IF;
                    ELSIF rec.f2 = 'years' THEN
                        curr_date := curr_date + INTERVAL '1 year' * rec.f1 * iter;
                    ELSE
                        RAISE EXCEPTION 'Invalid frequency type on order ID %', rec.id;
                    END IF;
                    iter := iter + 1;
                END LOOP;
        END LOOP;

    RAISE NOTICE 'Order occurrences generated successfully.';
END;
$$ LANGUAGE plpgsql;
