CREATE TABLE IF NOT EXISTS public.singleorder
(
    id                     integer not null
        primary key,
    descr                  text,
    wt                     boolean,
    amount                 varchar(10),
    planned_execution_date date
);

create table IF NOT EXISTS public.repeatedorder
(
    id             integer not null
        primary key,
    descr          text,
    wt             boolean,
    amount         varchar(10),
    f1             integer,
    f2             text,
    f3             text,
    repeatingtimes integer,
    rlim           text,
    rinitdd        integer,
    rinitmm        integer,
    rinityy        integer,
    rfindd         integer,
    rfinmm         integer,
    rfinyy         integer
);

create table IF NOT EXISTS transaction
(
    id            integer generated by default as identity
        primary key,
    descr         text,
    amount        varchar(10),
    orderid       integer,
    executiondate date,
    iduser        bigint
);

DROP FUNCTION IF EXISTS public.getFirstId();
CREATE FUNCTION public.getFirstId()
    RETURNS INTEGER AS
$$
DECLARE
    missing_id INTEGER;
BEGIN
    WITH all_ids AS (SELECT id
                     FROM SingleOrder
                     UNION
                     SELECT id
                     FROM RepeatedOrder),
         numbers AS (SELECT generate_series(1, (SELECT COALESCE(MAX(id), 0) + 1 FROM all_ids)) AS generate_series)
    SELECT MIN(n.generate_series)
    INTO missing_id
    FROM numbers n
             LEFT JOIN all_ids a ON n.generate_series = a.id
    WHERE a.id IS NULL;

    RETURN missing_id;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS public.generateOrderOccurrences(INT8, INT8);

CREATE FUNCTION public.generateOrderOccurrences(
    end_preview INT8,
    id_user INT8
)
    RETURNS VOID AS
$$
DECLARE
    rec       RECORD; -- Variable to hold each row from repeatedorder
    init_date DATE; -- Variable for calculating the date in the loop
    curr_date DATE; -- Variable for tracking the current date in the loop
    end_date  DATE; -- Calculated end date
    end_prev  DATE; -- Calculated end date
    iter      INT; --iteration number
BEGIN
    end_prev := to_timestamp(end_preview * 86400)::date;
    FOR rec IN SELECT * FROM repeatedorder
        LOOP

            IF rec.f3 = 'eoy' THEN
                init_date = (date_trunc('year', MAKE_DATE(rec.rinityy, 1, 1)) + interval '1 year - 1 day')::date;
            ELSIF rec.f3 = 'eom' OR
                  rec.rinitdd > EXTRACT('DAY' FROM (date_trunc('month', MAKE_DATE(rec.rinityy, rec.rinitmm, 1)) + interval '1 month - 1 day')::date)
            THEN
                init_date = (date_trunc('month', MAKE_DATE(rec.rinityy, rec.rinitmm, 1)) + interval '1 month - 1 day')::date;
            ELSE
                init_date = MAKE_DATE(rec.rinityy, rec.rinitmm, rec.rinitdd);
            end if;

            IF rec.rlim = 'to a specific date' THEN
                IF rec.f3 = 'eoy' THEN
                    end_date = (date_trunc('year', MAKE_DATE(rec.rfinyy, 1, 1)) + interval '1 year - 1 day')::date;
                ELSIF rec.f3 = 'eom' or
                      rec.rfindd >
                      EXTRACT('DAY' FROM (date_trunc('month',  MAKE_DATE(rec.rfinyy, rec.rfinmm, 1)) + interval '1 month - 1 day')::date)
                THEN
                    end_date = (date_trunc('month', MAKE_DATE(rec.rfinyy, rec.rfinmm, 1)) + interval '1 month - 1 day')::date;
                ELSE
                    end_date = MAKE_DATE(rec.rfinyy, rec.rfinmm, rec.rfindd);
                end if;
            END IF;

            -- Loop until the planned date exceeds the end date
            iter := 1;
            curr_date = init_date;
            WHILE curr_date <= end_prev and (rec.rlim = 'to a specific date' and curr_date <= end_date or
                                             rec.rlim = 'for a number of times' and iter <= rec.repeatingtimes)
                LOOP
                    -- Insert the occurrence into the new table
                    INSERT INTO public.transaction (orderid, iduser, descr, executiondate, amount)
                    VALUES (rec.id, id_user, rec.descr, curr_date, rec.amount);

                    -- Increment the planned date based on the frequency type
                    IF rec.f2 = 'days' THEN
                        curr_date := init_date + INTERVAL '1 day' * rec.f1 * iter;
                    ELSIF rec.f2 = 'months' THEN
                        curr_date = init_date + INTERVAL '1 month' * rec.f1 * iter;
                        IF rec.f3 = 'eom' THEN
                            curr_date = (date_trunc('month', curr_date) + interval '1 month - 1 day')::date;
                        END IF;
                    ELSIF rec.f2 = 'years' THEN
                        curr_date := curr_date + INTERVAL '1 year' * rec.f1 * iter;
                        IF rec.f3 = 'eom' THEN
                            curr_date = (date_trunc('month', curr_date) + interval '1 month - 1 day')::date;
                        ELSIF rec.f3 = 'eoy' THEN
                            curr_date = date_trunc('year', curr_date) + interval '1 year - 1 day';
                        END IF;
                    ELSE
                        RAISE EXCEPTION 'Invalid frequency type on order ID %', rec.id;
                    END IF;
                    iter := iter + 1;
                END LOOP;
        END LOOP;
    RAISE NOTICE 'Order occurrences generated successfully.';
END;
$$ LANGUAGE plpgsql;
